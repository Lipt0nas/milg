#version 460

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable

#define WORKGROUP_SIZE 32
#define NODE_SIZE 3
#define TREE_SCALE 8

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout(rgba8, set = 0, binding = 0) uniform image2D out_image;

layout(push_constant) uniform PushConstants {
    vec2 inverse_resolution;
    vec2 resolution;
    mat4 projection_matrix;
    mat4 view_matrix;
    vec4 position;
    uint32_t node_count;
    uint32_t leaf_count;
} push_constants;

struct Node {
    uint32_t packed_data[3];
};

layout(std140, binding = 1) readonly buffer SvoSSBOIn {
    Node data[];
} nodes;

layout(std140, binding = 2) readonly buffer SvoLeavesSSBOIn {
    uint8_t data[];
} leaves;

void get_primary_ray(vec2 uv, out vec3 ray_pos, out vec3 ray_dir) {
    uv = uv * 2.0 - 1.0;

    vec4 far = inverse(push_constants.projection_matrix) * vec4(uv, 1.0, 1.0);

    ray_dir = normalize(far.xyz / far.w);
    ray_dir = (inverse(push_constants.view_matrix) * vec4(ray_dir, 0.0)).xyz;

    ray_pos = vec3(push_constants.position);
}

vec2 intersect_aabb(vec3 origin, vec3 invDir, vec3 bbMin, vec3 bbMax) {
    vec3 t0 = (bbMin - origin) * invDir;
    vec3 t1 = (bbMax - origin) * invDir;
    vec3 temp = t0;
    t0 = min(temp, t1), t1 = max(temp, t1);
    float tmin = max(max(t0.x, t0.y), t0.z);
    float tmax = min(min(t1.x, t1.y), t1.z);
    return vec2(tmin, tmax);
}

vec3 floor_scale(vec3 pos, int scale_exp) {
    uint mask = ~0u << scale_exp;

    uvec3 iv = uvec3(floatBitsToUint(pos.x) & mask, floatBitsToUint(pos.y) & mask, floatBitsToUint(pos.z) & mask);

    return vec3(uintBitsToFloat(iv.x), uintBitsToFloat(iv.y), uintBitsToFloat(iv.z));
}

int get_node_cell_index(vec3 pos, int scale_exp) {
    uvec3 cell_pos = uvec3(floatBitsToUint(pos.x) >> scale_exp & 3, floatBitsToUint(pos.y) >> scale_exp & 3, floatBitsToUint(pos.z) >> scale_exp & 3);
    return int(cell_pos.x + cell_pos.z * 4 + cell_pos.y * 16);
}

//
// vec3 mirrored_pos(vec3 pos, vec3 dir, bool range_check) {
//     uvec3 iv = ivec3(floatBitsToUInt(pos.x) ^ 0x7FFFFF, floatBitsToUInt(pos.y) ^ 0x7FFFFF, floatBitsToUInt(pos.z) ^ 0x7FFFFF);
//     vec3 mirrored = vec3(uintBitsToFloat(iv.x), uintBitsToFloat(iv.y), uintBitsToFloat(iv.z));
// }

uvec3 vec_to_uvec_bit(vec3 input_vec) {
    return uvec3(floatBitsToUint(input_vec.x), floatBitsToUint(input_vec.y), floatBitsToUint(input_vec.z));
}

vec3 uvec_to_vec_bit(uvec3 input_vec) {
    return vec3(uintBitsToFloat(input_vec.x), uintBitsToFloat(input_vec.y), uintBitsToFloat(input_vec.z));
}

bool is_leaf(Node node) {
    return (node.packed_data[0] & 1) != 0;
}

uint child_ptr(Node node) {
    return node.packed_data[0] >> 1;
}

uint64_t child_mask(Node node) {
    return node.packed_data[1] | uint64_t(node.packed_data[2]) << 32;
}

uint popcnt_var64(uint64_t mask, uint width) {
    uint himask = uint(mask);
    uint count = 0;

    if (width >= 32) {
        count = bitCount(himask);
        himask = uint(mask >> 32);
    }
    uint m = 1u << (width & 31u);
    count += bitCount(himask & (m - 1u));

    return count;
}

struct HitData {
    bool hit;
    vec3 color;
    vec3 normal;
    vec3 pos;
};

HitData cast_ray(vec3 origin, vec3 dir) {
    uint32_t stack[11];
    int scale_exp = 21;

    uint32_t root_idx = 0;
    Node node = nodes.data[root_idx];
    stack[scale_exp >> 1] = root_idx;

    if (abs(dir.x) < 0.0001) dir.x = 0.0001;
    if (abs(dir.y) < 0.0001) dir.y = 0.0001;
    if (abs(dir.z) < 0.0001) dir.z = 0.0001;

    int sign_mask = 0, step_idx = 0, curr_idx = 0;
    if (dir.x < 0) sign_mask |= 0x11 << 0;
    if (dir.y < 0) sign_mask |= 0x11 << 4;
    if (dir.z < 0) sign_mask |= 0x11 << 2;

    vec3 inv_dir = 1.0 / dir;
    vec3 pos = floor_scale(origin, scale_exp);
    pos = clamp(pos, 1.0f, 1.9999999f);

    float tmin = 0.0f;
    int j = 0;

    for (j = 0; j < 128; j++) {
        float scale = intBitsToFloat((scale_exp - 23 + 127) << 23);
        vec3 sideDist = (step(0.0f, dir) * scale + (pos - origin)) * inv_dir;

        curr_idx = get_node_cell_index(pos, scale_exp);
        uint64_t mask = child_mask(node);

        for (int i = 0; i < 11; i++) {
            if ((mask >> curr_idx & 1) != 0) break;

            if (sideDist.x < sideDist.y && sideDist.x < sideDist.z) {
                sideDist.x += abs(inv_dir.x) * scale;
                step_idx = 1;
            } else if (sideDist.y < sideDist.z) {
                sideDist.y += abs(inv_dir.y) * scale;
                step_idx = 16;
            } else {
                sideDist.z += abs(inv_dir.z) * scale;
                step_idx = 4;
            }

            int prev_idx = curr_idx;
            curr_idx += (step_idx ^ sign_mask) - sign_mask;

            if (uint(prev_idx ^ curr_idx) >= uint(step_idx << 2)) {
                curr_idx = -1;
                break;
            }
        }

        if (curr_idx >= 0) {
            if (step_idx == 1) sideDist.x -= abs(inv_dir.x) * scale;
            if (step_idx == 4) sideDist.z -= abs(inv_dir.z) * scale;
            if (step_idx == 16) sideDist.y -= abs(inv_dir.y) * scale;

            if (step_idx == 0) {
                sideDist.x = 0;
            }

            tmin = min(min(sideDist.x, sideDist.y), sideDist.z);
            vec3 hit_pos = origin + tmin * dir;

            if (is_leaf(node)) break;

            uvec3 childPos = uvec3(curr_idx) >> uvec3(0, 4, 2) & 3u;
            childPos = (vec_to_uvec_bit(pos) & (~3u << scale_exp)) | childPos << scale_exp;

            int child_scale_exp = scale_exp - 2;
            uvec3 subPos = clamp(vec_to_uvec_bit(hit_pos), childPos, childPos | (3u << child_scale_exp));
            subPos &= ~0u << child_scale_exp; // floor

            pos = uvec_to_vec_bit(subPos);

            uint node_idx = child_ptr(node) + popcnt_var64(child_mask(node), curr_idx);
            stack[scale_exp >> 1] = node_idx; // push
            scale_exp = child_scale_exp;

            node = nodes.data[node_idx];
        } else {
            uvec3 parentPos = vec_to_uvec_bit(pos);

            // Compute step position to figure out the parent scale. For example,
            // if we are at scale 1/64 and step crosses boundary of node 1/4, climb directly to it.
            int stepDelta = (sign_mask & step_idx) != 0 ? -1 : +1;
            int stepPos;
            if (step_idx == 1) stepPos = int(parentPos.x);
            if (step_idx == 4) stepPos = int(parentPos.z);
            if (step_idx == 16) stepPos = int(parentPos.y);

            int parent_scale_exp = scale_exp + 2;
            scale_exp = findMSB(stepPos ^ (stepPos + (stepDelta << parent_scale_exp))); // 31 - lzcnt
            if (scale_exp % 2 == 0) scale_exp--; // dunno why diff gets misaligned, but this seems to work alright

            if (scale_exp > 21) break;

            // Step again using actual scale
            parentPos &= ~0u << scale_exp;

            stepDelta <<= scale_exp;
            if (step_idx == 1) parentPos.x += stepDelta;
            if (step_idx == 4) parentPos.z += stepDelta;
            if (step_idx == 16) parentPos.y += stepDelta;

            pos = uvec_to_vec_bit(parentPos);

            uint node_idx = stack[scale_exp >> 1];
            node = nodes.data[node_idx]; // pop
        }
    }

    HitData hit;
    hit.hit = false;

    if (is_leaf(node)) {
        hit.hit = true;
        hit.pos = origin + tmin * dir;
        hit.color = unpackUnorm4x8(node.packed_data[0]).xyz;

        bvec3 side_mask = bvec3(step_idx == 1, step_idx == 16, step_idx == 4);
        hit.normal = vec3(side_mask.x ? -sign(dir.x) : 0.0, side_mask.y ? -sign(dir.y) : 0.0, side_mask.z ? -sign(dir.z) : 0.0);

        return hit;
    }

    return hit;
}

// for (int i = 0; i < 256; i++) {
//     uint child_idx = get_node_cell_index(pos, scale_exp);
//
//     int iters = 0;
//     while (!is_leaf(node) && (child_mask(node) >> child_idx & 1) != 0) {
//         uint child_slot = popcnt_var64(child_mask(node), child_idx);
//         node = nodes.data[child_ptr(node) + child_slot];
//
//         scale_exp -= 2;
//         child_idx = get_node_cell_index(pos, scale_exp);
//
//         iters++;
//         if (iters >= 100000) {
//             break;
//         }
//     }
//
//     if (is_leaf(node) && (child_mask(node) >> child_idx & 1) != 0) {
//         break;
//     }
//
//     float scale = intBitsToFloat((scale_exp - 23 + 127) << 23);
//
//     vec3 cell_min = floor_scale(pos, scale_exp);
//     vec3 cell_size = vec3(scale);
//
//     vec3 side_pos = cell_min + step(0.0, dir) * cell_size;
//     side_dist = (side_pos - origin) * inv_dir;
//
//     tmax = min(min(side_dist.x, side_dist.y), side_dist.z) + 0.0001;
//
//     pos = origin + tmax * dir;
// }
//
// if (is_leaf(node) && scale_exp <= 21) {
//     hit.hit = true;
//     hit.color = vec3(unpackUnorm4x8(node.packed_data[1]));
//     hit.pos = pos;
//
//     bvec3 side_mask = bvec3(tmax >= side_dist.x, tmax >= side_dist.y, tmax >= side_dist.z);
//     hit.normal = vec3(side_mask.x ? -sign(dir.x) : 0.0, side_mask.y ? -sign(dir.y) : 0.0, side_mask.z ? -sign(dir.z) : 0.0);
// }

// return hit;
// }

void main() {
    ivec2 sample_pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(sample_pos + vec2(0.5)) * push_constants.inverse_resolution;

    vec3 out_color = vec3(1.0, 1.0, 1.0);
    vec3 ray_pos = vec3(0.0);
    vec3 ray_dir = vec3(0.0);

    get_primary_ray(uv, ray_pos, ray_dir);

    HitData hit = cast_ray(ray_pos, ray_dir);
    if (hit.hit) {
        out_color = hit.color;
    }

    imageStore(out_image, sample_pos, vec4(out_color, 1));
}
