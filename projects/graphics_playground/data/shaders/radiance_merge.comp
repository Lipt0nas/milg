#version 460

#include "common.glsl"

layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;

layout(rgba8, set = 0, binding = 0) uniform readonly image2D in_next;
layout(rgba8, set = 0, binding = 1) uniform readonly image2D in_current;
layout(rgba8, set = 0, binding = 2) uniform image2D out_image;

layout(push_constant) uniform PushConstants {
    float render_extent;
    float cascade_spacing;
    float cascade_interval;
    float cascade_angular;
    int cascade_index;
    int cascade_extent;
} push_constants;

struct ProbeTexel {
    float count;
    float size;
    float index;
    vec2 texel;
    vec2 probe;
};

ProbeTexel cascade_probe_texel(vec2 coord, float cascade) {
    float count = push_constants.cascade_angular * pow(4.0, cascade);
    float size = sqrt(count);
    vec2 texel = mod(floor(coord), vec2(size));
    float index = (texel.y * size) + texel.x;
    vec2 probe = floor(coord / vec2(size));

    return ProbeTexel(count, size, index, texel, probe);
}

vec4 cascade_fetch(ProbeTexel probe_info, vec2 texel_index, float theta_index) {
    ivec2 size = imageSize(in_current);
    vec2 probeTexel = texel_index * probe_info.size;
    probeTexel += vec2(mod(theta_index, probe_info.size), theta_index / probe_info.size);
    vec2 cascadeTexelPosition = probeTexel / push_constants.cascade_extent;

    if (cascadeTexelPosition.x < 0.0 || cascadeTexelPosition.y < 0.0 || cascadeTexelPosition.x >= 1.0 || cascadeTexelPosition.y >= 1.0)
        return vec4(0.0, 0.0, 0.0, 0.0);

    return imageLoad(in_next, ivec2(cascadeTexelPosition * size));
}

void main() {
    ivec2 size = imageSize(in_current);
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(texel + vec2(0.5)) / push_constants.render_extent;

    ProbeTexel probe_info = cascade_probe_texel(texel, push_constants.cascade_index);
    ProbeTexel probe_infoN1 = cascade_probe_texel(texel, push_constants.cascade_index + 1.0);

    vec2 texel_index = floor((vec2(probe_info.probe) - 1.0) / 2.0);
    vec2 texel_indexN1 = floor((texel_index * 2.0) + 1.0);

    vec4 radiance = imageLoad(in_current, ivec2(texel_index * size));
    radiance.a = 1.0 - radiance.a;

    if (radiance.a != 0.0 && push_constants.cascade_index < 5.0 - 1.0) {
        vec4 TL = vec4(0.0), TR = vec4(0.0),
        BL = vec4(0.0), BR = vec4(0.0);

        // We always default to a 4x ray branch scaling between cascades.
        const float branch4 = 4.0;
        for (float i = 0.0; i < branch4; i++) {
            float thetaIndexN1 = (probe_info.index * branch4) + i;
            TL += cascade_fetch(probe_infoN1, texel_index + vec2(0.0, 0.0), thetaIndexN1);
            TR += cascade_fetch(probe_infoN1, texel_index + vec2(1.0, 0.0), thetaIndexN1);
            BL += cascade_fetch(probe_infoN1, texel_index + vec2(0.0, 1.0), thetaIndexN1);
            BR += cascade_fetch(probe_infoN1, texel_index + vec2(1.0, 1.0), thetaIndexN1);
        }

        // Per Specification:
        vec2 weight = vec2(0.25) + (vec2(probe_info.probe) - texel_indexN1) * vec2(0.5);

        // Smoother Weights:
        // vec2 weight = vec2(0.33) + (vec2(probe_info.probe) - texel_indexN1) * vec2(0.33);

        vec4 interpolated = mix(mix(TL, TR, weight.x), mix(BL, BR, weight.x), weight.y) / branch4;
        interpolated.a = 1.0 - interpolated.a;
        radiance += radiance.a * interpolated;
    }

    imageStore(out_image, texel, vec4(radiance.rgb, 1.0));
}
